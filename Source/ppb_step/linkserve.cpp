//*****************************************************************************
//	linkserve.c
//
// Philosophy:
//	We are going to assume that master checks any Up or Down block
//  transfer calls to be sure that with array types and count parameters
//	the requested transfers fit into Command and Response reports. We
//  will guard against overruns here, but if they occur we will assume it
//	represents misbehavior of slave function.
//
// LinkServe functions go here. There may be multiple links on a Slave target.
// Typically only two (maybe a serial interface and USB, not necessarily from
// the same host). The links must be called from the background loop. The LinkServe()
// function(s) notice when a command has been received, execute the function and post
// the response to ISR functions. The service happens quickly when a command is detected.
// The link function should be execute quickly, certainly within 20 msec to keep background
// loop responsive. All the communication occurs in ISRs outside the scope of the LinkServe()
// calls.
// This module has common functions to interface with the slave.c functionality:
// GetFDef(), RcvChar(), SendChar(), InitSlaveLink(), and SetExPhase(),
//
//*****************************************************************************
#include "project.h"
#include "hostopsys.h"
//#include <stdio.h>
#include <string.h>
#include "mlink.h"
#include "slink.h"
#include "linkctrl.h"

void EnableTXPin();

//DFDEBUG
void TurnLEDOn();

static LINK_CONTROL LCtrl;
U8 ReturnError, BlockError, ParamError;

U8 SetExPhase(U8 Phase, U32 Parm)
{
	switch(Phase)
	{
		case EX_START: //A raw link command buffer is pointed to by LCtrl.CmdBuff
					  //May be error indication in LCtrl.Error. LCtrl.ByteCount holds command length
			ParamError = ReturnError = BlockError = FALSE;
			LCtrl.Index = 0;//start at beginning of link command
			LCtrl.IndexLimit = 0;//meaning only can fetch FIdx, after which
								   //IndexLimit is set to limit of specified function's
								   //arguments during GetFDef() call
			LCtrl.FIdx = LCtrl.CmdBuff[0];
			break;

		case EX_PARM:
			//Note:GetFDef() sets LCtrl.FunSize = FDefP->FunSize
			LCtrl.IndexLimit = Parm; //# of bytes of parameters
			LCtrl.Index = 1;//start of parameters
			LCtrl.ExMode = EX_PARM;
			break;

		case EX_CALL:
			LCtrl.Index = LCtrl.IndexLimit + 1;//Set index to first byte after params
			LCtrl.IndexLimit = LCtrl.ByteCount;
			LCtrl.ByteCount = 0;
			LCtrl.ExMode = EX_CALL;//so now slave.c can use RcvChar to get DownBlock bytes out
									//working up to ByteCount, the total bytes in the command
			break;

		case EX_UP:	//called if byte is sent during EX_CALL phase
			LCtrl.Index = LCtrl.FunSize;//point right after return value
			LCtrl.IndexLimit = LCtrl.MaxReturnSize - 1;
			break;

		case EX_RETURN:	//sending any return value happens in this mode
			if(LCtrl.ExMode == EX_UP)
			{
				LCtrl.ByteCount = LCtrl.Index;
			}
			else
			{
				if(LCtrl.FunSize)
				{
					LCtrl.IndexLimit = LCtrl.FunSize - 1;
				}
				else
				{
					LCtrl.IndexLimit = 0;
				}
				LCtrl.ByteCount = LCtrl.FunSize;
			}
			LCtrl.Index = 0;
			break;

		case EX_IDLE:	//All done. Finalize the response
			if(Parm != LE_NO_ERROR)
			{
				LCtrl.ReturnStatus = (U8)Parm;
			}
			else if(ParamError)
			{
				LCtrl.ReturnStatus = LE_BAD_PARAM;
			}
			else if(ReturnError)
			{
				LCtrl.ReturnStatus = LE_BAD_RETURN;
			}
			else if(BlockError)
			{
				LCtrl.ReturnStatus = LE_BAD_BLOCK;
			}
			else
			{
				LCtrl.ReturnStatus = LE_NO_ERROR;
			}
			//If we actually called the function, ExMode will be EX_RETURN
			//and ByteCount is count of total generated bytes for response and BlockUp
			if(LCtrl.ExMode != EX_RETURN)
			{
				LCtrl.ByteCount = 0;//we did not actually call the function
			}
			break;

		default:
			PostLogicError(BAD_EXMODE_LOGIC_ERROR);
			break;
	}
	LCtrl.ExMode = Phase;
	return LE_NO_ERROR;
}


U32 GetFDef(U8 FIdx, struct LinkDef *FDefP)
{
	struct LinkDef *SDef;
	int ParmLimit = 0;
	U32 Count;

	//For now Serial and USB links have same linklist
	Count = GetCurFDef(&SDef);

	if(	FIdx >= Count)
	{
		return FALSE;
	}
	*FDefP = SDef[FIdx];
	FDefP->Arg1Size &= (U8)(~PTR_TYPE_MASK);
	ParmLimit +=  FDefP->Arg1Size;
	FDefP->Arg2Size &= (U8)(~PTR_TYPE_MASK);
	ParmLimit +=  FDefP->Arg2Size;
	FDefP->Arg3Size &= (U8)(~PTR_TYPE_MASK);
	ParmLimit +=  FDefP->Arg3Size;
	FDefP->Arg4Size &= (U8)(~PTR_TYPE_MASK);
	ParmLimit +=  FDefP->Arg4Size;
	LCtrl.FunSize = FDefP->FunSize;
	SetExPhase(EX_PARM, (U16)ParmLimit);
	return TRUE;
}


void LinkServe(void)
{
    U8 Result = LE_NO_ERROR;
    U8 DevAddress;

    int NumLinks = GetNumLinks();

    for(int i = 0; i < NumLinks; ++i)
    {
        SetLinkIndex((U8)i);
        if((LCtrl.ByteCount = GetLinkCommandPacket(&LCtrl.CmdBuff, &LCtrl.RspBuff, &LCtrl.MaxReturnSize)) != 0)
        {
		    DevAddress = LCtrl.CmdBuff[0] >> 5;

		    LCtrl.FIdx = LCtrl.CmdBuff[0] &= 0X1F;//save the FIdx
		    //we will assume for now that it is addressed to us.
		    pinMode(TX_PIN, OUTPUT);
		    //EnableTXPin(); //Enable TX pin as we are grabbing serial line for response.
		    if((Result = SetExPhase(EX_START, 0)) == LE_NO_ERROR)
		    {
			   Result = SlaveLinkProc();//gets params, executes the function, sets errors if
			   							//necessary and puts return in buffer pointed at by LCtrl.RspBuff
		    }
		    SetExPhase(EX_IDLE, Result); //update LCtrl and put final link status in LCtrl.ReturnStatus
		    PostLinkResult(LCtrl.ByteCount, LCtrl.ReturnStatus, LCtrl.FIdx);//they add wrapper
		    LCtrl.ReturnStatus =  LE_NO_ERROR;
        }
    }
}


//Not expected to change for different link transports
U16 RcvChar(void)
{
	switch(LCtrl.ExMode)//probably overkill but we are only allowing char retrieval in appropriate phases
	{
		case EX_START: //We should be fetching FIdx
		case EX_PARM: //We should be fetching params in this phase
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				return LCtrl.CmdBuff[LCtrl.Index++];
			}
			else
			{
				ParamError = TRUE;
			}
			break;

		case EX_CALL: //We may be fetching BLOCK_DOWN bytes in this phase
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
					return LCtrl.CmdBuff[LCtrl.Index++];
			}
			else
			{
				BlockError = TRUE;
			}
			break;

		default:
			PostLogicError(RCV_CHAR_LOGIC_ERROR);
			break;
	}
	return 0XFFFF;
}

//Not expected to change for different link transports
U8 SendChar(U8 C)
{
	switch(LCtrl.ExMode)
	{
		case EX_CALL:
			SetExPhase(EX_UP, 0);//apparently function is sending EX_UP bytes to limit of PacketBuff
			//Intentional case drop-through
			//.
		case EX_UP:
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				LCtrl.RspBuff[LCtrl.Index++] = C;
				return TRUE;
			}
			else
			{
				BlockError = TRUE;
			}
			break;

		case EX_RETURN:
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				LCtrl.RspBuff[LCtrl.Index++] = C;
				return TRUE;
			}
			else
			{
				ReturnError = TRUE;//set flag for debugger
			}
			break;

		default:
			PostLogicError(SEND_CHAR_LOGIC_ERROR);
			return FALSE;//we are messed up
	}
	return FALSE;
}

//Not expected to change for different link transports
bool RcvBlock(U8 * Buffer, U32 Count)
{
	if(LCtrl.ExMode == EX_CALL)
	{
		if((U32)(LCtrl.Index + Count) <= (U32)(LCtrl.IndexLimit + 1))
		{
			memcpy(Buffer,  &(LCtrl.CmdBuff[LCtrl.Index]), Count);
			LCtrl.Index = (U16)(LCtrl.Index + Count);
			return true;
		}
	}
	return false;
}

//Not expected to change for different link transports
bool SendBlock(U8 * Buffer, U32 Count)
{
	if(LCtrl.ExMode == EX_CALL)
	{
	    SetExPhase(EX_UP, 0);
	}
	if(LCtrl.ExMode == EX_UP)
	{
		if((U32)(LCtrl.Index + Count) <= (U32)(LCtrl.IndexLimit + 1))
		{
				memcpy(&(LCtrl.RspBuff[LCtrl.Index]), Buffer, Count);
				LCtrl.Index = (U16)(LCtrl.Index + Count);
				return true;
		}
	}
	return false;
}
