Notes on stepper control for helix winder. Using ST-M5045 drivers along with
the PPB Controller board. The PPB Controller will produce step pulses for up
to three steppers. For now, not planning to have programmed direction control,
nor enable. These will be controlled with jumpers. THe PPB controller
only produces step pulses. Keeping it simple, I will not have ramping, just
setting of pulse rate in sub-multiples of 1K. 1000, 500, 333.33, 250, 200,
166.67, 142.86, 125.. I think I will just supply number of steps followed
by divisor. Possibly I will want a continuous run function. Also maybe a position
function.


Run(ID, Divisor, Direction

May be marginally simpler to program the direction.
Common enable for all.
A4, A5, A6, and A7 are free on PPB controller. Also can use Aux I/O x 5.
So have nine outputs. Also have B5 output available (but complicated
as this controls built-in LED and TELL_TALE).
So since A4-A7 are totally unused, am going to use them for A4, A5, A6 as
stepper enables (active low).
A7, D2, D3,
So I can do three steppers with Step, Dir, Enable.
So enable will be turned on automatically by a move.
It also will have On/Off control.
Will require command to turn off after move.

So we have StepperMove() command with a step count up to 65535.
65535 will be infinite move. IF we send a new move while moving,
it replaces the count of any currently active move. A move of zero will
stop an existing move.

The millisecond divisor is sent with the command along with direction.

StepperMove(Index, Divisor, Steps, Direction)

On each millisecond interrupt, we will step any stepper
whose count is non-zero. We will not keep track of direction of move, but
will set the direction control line to value received in command.
So for each stepper, we have an unsigned integer step count which counts
down if non-zero. We also have a step divider (byte) which is set by
StepperMove() command and counts up on millisecond interrupts to step
interval count (one per stepper and set by StepperMove()).

 So nothing will happen as long as Count is zero. If count is non-zero,
 we decrement step divider, and if it reaches zero we do a step, that is,
 we activate the step line.



Ramping control---
We work on time basis. We start in RAMP_UP state and do a vel adjustment every
20 milliseconds.  When starting move, we compute TCrit1 which is time to either
plateau or start of ramp-down. If there is no plateau, TCrit2 is zero, otherwise
it is the non-zero ramp-down start time.
During ramp-up, we add to current velocity Acc*0.02, and convert to period and load it.
During computation, we also see what next state will be.

SO our periods must be at least 10 counts. We can time periods up to 256 counts in one
cycle. Problem is if we have a period whose remainder is  less than 10 counts after
a number of 256 count timings. So maybe we devise a way to break up one of the full
counts to less than full count, say maybe half count, then add the half count to remainder
to get a count long enough. Maybe we for longer periods, we always time half, then for last
cycle we add the last half time to the remainder. THe problem occurs when the residual is
too small. We need to time as many 128 counts as needed then add 128 to the remainder.
So we preprocess the period a bit so that it consists of a count of 128 periods plus a remainder
bigger than our min safe count.
So we check the remainder. If it is too small, we subtract one from the upper portion,
and add 128 to lower portion. Then we double the upper portion to get a count of 128 cycles
rather than a count of 256 cycles. We need to limit the maximum period. Now it is max of 255 * 256 * 4   USec
or .26 seconds.or 4 Hz.

So incoming period must fit in 15 bits - 32767. We then double the upper byte, which was 127 or less and 254 or
less when doubled.  We then look at lower byte. If it is less than 128, we add 128 to it and subtract one from
the high byte. At worst then the low byte would be 255. We already need to handle low bytes of 255 for periods
just under 256 counts. So.. our timing periods will always be at least 128 counts. So maybe we leave code much
the same in ISR's. We still time the step pulse with a short delay which is

No actually we allow timing periods as short as say 20 counts. In this case we end up with
a really short timing cycle for the short timing cycle after the one for the pulse.
So maybe we time the pulse with padding in ISR.


SO to recap: We want to time the Step pulse with code execution delay in ISR.
We want no timing cycles to be less than the minimum rate we allow, currently 10 counts for step period count,
each Count representing  being 4 USec based on T0 divide. T0 cycle is 1024 USec.

So when starting step timing in ISR, we want to be sure the low byte of delay is 10 or greater.
The problem, is that to guarantee this we may need to add counts to smaller low bytes when
we time the short period. The high byte represents full 256 count periods (for longer periods).
Was hoping to  preserve most of the full period range. So if we adjust the first count by adding 128,
we need to flag that so that the first full cycle done based on high byte count is 128, reflecting
the counts shifted to low byte count. We should never have zero in high byte if the low byte was less
than 10 or we would have violated min delay limit of ten counts.
So if we steal half a cycle from high byte counts, we need only make the first count cycle  half
of a full count. So we use a flag.


Want a random move program. It will make moves in a semi random fashion so it does not
wander out of working range. Basic move is a random choice of direction and distance.
First choose direction, then randomly choose distance out of range available for selected distance.

Or:
Cycle of moves from initial longest move to final shortest move of say 500. Direction reverses each time.
We start it out with a distance and a direction. It intially moves the starting distance, then reverses and moves half that and so on
until final move which is Minimum given in call. Keeps track of position relative to start.  The position at start
and the initial direction and distance define the working range.

Or:
Take an initila move of 56000 at slew speed in negative direction to find zero limit.
Then take ramp move of 56000 in positive direction starting cycle. After each move reverse
until minimum move of 500 is done. Then move to opposite end and do the same.


 We advance state whenever S2StepCount is zero.
 We restart the cycle by setting CurMove to zero.
void  DoCycleMove()
 {
    if(CycleMove && (S2StepCount == 0))
    {
        if(CurMove == 0)
        { //time to do the slew move
            SetStep(1, SLEW_PERIOD_COUNT, HOME_MOVE, SlewDir);
            CurMove = MAX_MOVE;
            SlewDir = !SlewDir;
            CurDir = SlewDir;
        }
        else
        {
            if(CurMove == MIN_CYCLE_MOVE)
            {
                CurMove = 0;
            }
            else
            {
                CurMove /= 2;
                CurMove = CurMove < MIN_CYCLE_MOVE ? MIN_CYCLE_MOVE : CurMove;
                SetStep(1 + 4, 0, CurMove, CurDir);//ramp move
                CurDir = !CurDir;
            }
        }
    }
 }
so maybe another SetStep flag to control cycle move. If it is set, then
void SetStep(U8 StepperIndex, U16 PeriodCount, U16 Steps, U8 Dir)
we init SlewDir to the Dir parameter. We set CurMove to zero, and set CycleMove true.
However if Steps is zero, we set CycleMove to false which kills cycle.
