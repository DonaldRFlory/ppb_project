//*****************************************************************************
//	linkserve.c
//
// Philosophy:
//	We are going to assume that master checks any Up or Down block
//  transfer calls to be sure that with array types and count parameters
//	the requested transfers fit into Command and Response reports. We
//  will guard against overruns here, but if they occur we will assume it
//	represents misbehavior of slave function.
//
// LinkServe functions go here. There may be multiple links on a Slave target.
// Typically only two (maybe a serial interface and USB, not necessarily from
// the same host). The links must be called from the background loop. The LinkServe()
// function(s) notice when a command has been received, execute the function and post
// the response to ISR functions. The service happens quickly when a command is detected.
// The link function should be execute quickly, certainly within 20 msec to keep background
// loop responsive. All the communication occurs in ISRs outside the scope of the LinkServe()
// calls.
// This module has common functions to interface with the slave.c functionality:
// GetFDef(), RcvChar(), SendChar(), InitSlaveLink(), and SetExPhase(),
//
//*****************************************************************************

#include "type.h"
#include "target.h"
#include "link.h"
#include "slink.h"

#ifdef __cplusplus
   extern "C" {
#endif
#if (USING_HID_LINK)
void PostHIDResult(U16 ByteCount, U8 Status, U8 FIdx);
void InitHIDLink(void);
int GetHIDCommandPacket(U8 **CmdPtrAddress, U8 **RspPtrAddress, U16 *MaxReturnSizeAddress);
U16 HIDMaxLinkSend(void);
U16 HIDMaxLinkReturn(void);
#endif

#if (USING_SER_LINK)
void PostSerialResult(U16 ByteCount, U8 Status, U8 FIdx);
U16 SerMaxLinkSend(void);
U16 SerMaxLinkReturn(void);
void InitSerialLink(void);
int GetSerialCommandPacket(U8 **CmdPtrAddress, U8 **RspPtrAddress, U16 *MaxReturnSizeAddress);
#endif

#ifdef __cplusplus
   }
#endif

//Values for LinkType:
#define SERIAL_LINK 0
#define HID_LINK 1

static U8 LinkType;//Set during LinkServe processing to indicate the link we are
	//servicing. It will allow us to possibly return function def from a different
	//LinkDef table for each link in GetFDef().

U8 ReturnError, BlockError, ParamError;

//Common to all transports. For the link currently being serviced.
static LINK_CONTROL LCtrl;

#if 0
U8 GetLinkType(void)
{
	return LinkType;
}
#endif

void InitSlaveLink(void)
{
#if (USING_SER_LINK)
	InitSerialLink();
#endif

#if (USING_HID_LINK)
	InitHIDLink();
#endif
	LCtrl.ExMode = EX_IDLE;
}

U8 SetExPhase(U8 Phase, U16 Parm)
{
	switch(Phase)
	{
		case EX_START: //A raw link command buffer is pointed to by LCtrl.CmdBuff
					  //May be error indication in LCtrl.Error. LCtrl.ByteCount holds command length
			ParamError = ReturnError = BlockError = FALSE;
			LCtrl.Index = 0;//start at beginning of link command
			LCtrl.IndexLimit = 0;//meaning only can fetch FIdx, after which
								   //IndexLimit is set to limit of specified function's
								   //arguments during GetFDef() call
			LCtrl.FIdx = LCtrl.CmdBuff[0];
			break;

		case EX_PARM:
			//Note:GetFDef() sets LCtrl.FunSize = FDefP->FunSize
			LCtrl.IndexLimit = Parm; //# of bytes of parameters
			LCtrl.Index = 1;//start of parameters
			LCtrl.ExMode = EX_PARM;
			break;

		case EX_CALL:
			LCtrl.Index = LCtrl.IndexLimit + 1;//Set index to first byte after params
			LCtrl.IndexLimit = LCtrl.ByteCount;
			LCtrl.ByteCount = 0;
			LCtrl.ExMode = EX_CALL;//so now slave.c can use RcvChar to get DownBlock bytes out
									//working up to ByteCount, the total bytes in the command
			break;

		case EX_UP:	//called if byte is sent during EX_CALL phase
			LCtrl.Index = LCtrl.FunSize;//point right after return value
			LCtrl.IndexLimit = LCtrl.MaxReturnSize - 1;
			break;

		case EX_RETURN:	//sending any return value happens in this mode
			if(LCtrl.ExMode == EX_UP)
			{
				LCtrl.ByteCount = LCtrl.Index;
			}
			else
			{
				if(LCtrl.FunSize)
				{
					LCtrl.IndexLimit = LCtrl.FunSize - 1;
				}
				else
				{
					LCtrl.IndexLimit = 0;
				}
				LCtrl.ByteCount = LCtrl.FunSize;
			}
			LCtrl.Index = 0;
			break;

		case EX_IDLE:	//All done. Finalize the response
			if(Parm != LE_NO_ERROR)
			{
				LCtrl.ReturnStatus = Parm;
			}
			else if(ParamError)
			{
				LCtrl.ReturnStatus = LE_BAD_PARAM_FLAG;
			}
			else if(ReturnError)
			{
				LCtrl.ReturnStatus = LE_BAD_RETURN;
			}
			else if(BlockError)
			{
				LCtrl.ReturnStatus = LE_BAD_BLOCK;
			}
			else
			{
				LCtrl.ReturnStatus = LE_NO_ERROR;
			}
			//If we actually called the function, ExMode will be EX_RETURN
			//and ByteCount is count of total generated bytes for response and BlockUp
			if(LCtrl.ExMode != EX_RETURN)
			{
				LCtrl.ByteCount = 0;//we did not actually call the function
			}
			break;

		default:
			PostLogicError(BAD_EXMODE_LOGIC_ERROR);
			break;
	}
	LCtrl.ExMode = Phase;
	return LE_NO_ERROR;
}

//Max raw link command packet size
U16 MaxLinkSend(void)
{
	if(LinkType == HID_LINK)
	{
#if (USING_HID_LINK)
		return HIDMaxLinkSend();
#else
		return 0;
#endif
	}
	else
	{
#if (USING_SER_LINK)
		return SerMaxLinkSend();
#else
		return 0;
#endif
	}
}


//Max raw link response packet size
U16 MaxLinkReturn(void)
{
	if(LinkType == HID_LINK)
	{
#if (USING_HID_LINK)
		return HIDMaxLinkReturn();
#else
		return 0;
#endif
	}
	else
	{
#if (USING_SER_LINK)
		return SerMaxLinkReturn();
#else
		return 0;
#endif
	}
}

//Multiple links may share the same linklist
//or they may have distinct linklists.
extern int LinkCount;
extern struct LinkDef  SDef[];

U32 GetFDef(U8 FIdx, struct LinkDef *FDefP)
{
	int ParmLimit = 0;

	//For now Serial and USB links have same linklist
	if(	FIdx >= LinkCount)
	{
		return FALSE;
	}
	*FDefP = SDef[FIdx];
	FDefP->Arg1Size &= ~PTR_TYPE_MASK;
	ParmLimit +=  FDefP->Arg1Size;
	FDefP->Arg2Size &= ~PTR_TYPE_MASK;
	ParmLimit +=  FDefP->Arg2Size;
	FDefP->Arg3Size &= ~PTR_TYPE_MASK;
	ParmLimit +=  FDefP->Arg3Size;
	FDefP->Arg4Size &= ~PTR_TYPE_MASK;
	ParmLimit +=  FDefP->Arg4Size;
	LCtrl.FunSize = FDefP->FunSize;
	SetExPhase(EX_PARM, ParmLimit);
	return TRUE;
}


int GetSerialCommandPacket(U8 **CmdPtrAddress, U8 **RspPtrAddress, U16 *MaxReturnSizeAddress);
//(!ValidatePacket()) must be called in GetSerialCommandPacket before returning non-zero.
//non-zero return means valid packet received and CmdPtr, RspPtr, and MaxReturnSize are updated.

int GetHIDCommandPacket(U8 **CmdPtrAddress, U8 **RspPtrAddress, U16 *MaxReturnSizeAddress);

//L_IDLE means nothing happening, no command received, no response ready
//Typically receiving a Command causes one or more receive states ending
//in L_EXECUTE when a complete command packet is received.

//New code will hide comm layer details
void LinkServe(void)
{
    U8 Result = LE_NO_ERROR;

    #if (USING_SER_LINK)
    LinkType = SERIAL_LINK;//for benefit of MaxLinkSend(void) and MaxLinkReturn(void)
    if((LCtrl.ByteCount = GetSerialCommandPacket(&LCtrl.CmdBuff, &LCtrl.RspBuff, &LCtrl.MaxReturnSize)) != 0)
    {
		LCtrl.FIdx = LCtrl.CmdBuff[0];//save the FIdx
		if((Result = SetExPhase(EX_START, 0)) == LE_NO_ERROR)
		{
			   Result = SlaveLinkProc();//gets params, executes the function, sets errors if
			   							//necessary and puts return in buffer pointed at by LCtrl.RspBuff
		}
		SetExPhase(EX_IDLE, Result); //update LCtrl and put final link status in LCtrl.ReturnStatus
		PostSerialResult(LCtrl.ByteCount, LCtrl.ReturnStatus, LCtrl.FIdx);//they add wrapper
		LCtrl.ReturnStatus =  LE_NO_ERROR;
    }
    #endif //of if USING_SER_LINK

    #if (USING_HID_LINK)
    LinkType = HID_LINK; //for benefit of MaxLinkSend(void) and MaxLinkReturn(void)
    if(LCtrl.ByteCount = GetHIDCommandPacket(&LCtrl.CmdBuff, &LCtrl.ResBuff, &LCtrl.MaxReturnSize))
    {
        LCtrl.FIdx = LCtrl.CmdBuff[0];//save the FIdx
		if((Result = SetExPhase(EX_START, 0)) == LE_NO_ERROR)
		{
		   Result = SlaveLinkProc();//gets params, executes the function, sets errors if necessary and puts return
		}
		SetExPhase(EX_IDLE, Result); //update LCtrl and put final link status in LCtrl.ReturnStatus
	   	PostHIDResult(LCtrl.ByteCount, LCtrl.ReturnStatus, LCtrl.FIdx);//they add ReturnStatus and FIdx in front of our return packet
    }
    #endif //of if USING_HID_LINK
}

#if 0
    //old version
    //Called frequently by idle loop
void LinkServe(void)
{
	U8 Result = LE_NO_ERROR;
	//We handle both serial link and USB HID link here.

#if (USING_SER_LINK)
	LinkType = SERIAL_LINK;
 	switch(SerCtrl.State)
	{
		case SER_IDLE:
			break;

		case SER_FAULT:
		   	SerCtrl.State = SER_IDLE; //don't think we can get here but..
			break;

		case SER_RECEIVE:
			if(SerLinkTimer == 0)
			{
				++SerialTimeouts;
				SerCtrl.State = SER_FAULT;//to freeze ISR
				PostSerialResult(0, LE_SHORT_PACKET, 255); //invalid function index
				LCtrl.ReturnStatus = LE_NO_ERROR ;
			}
			break;

		case SER_RESULT:
			if(SerLinkTimer == 0)
			{ //Mainly so we never hang up out of sequence(while debugging perhaps)
				SerCtrl.State = SER_IDLE;
				++SerialTimeouts;
			}
			break;

		case SER_EXECUTE:
			if(!ValidatePacket())
			{
				break;
			}
			LCtrl.FIdx = LCtrl.CmdBuff[0];//save the FIdx
			LCtrl.ByteCount = SerCtrl.LCount;
			LCtrl.MaxReturnSize = SerCtrl.MaxReturnSize; //Space allowed for our raw link response.
														//SerCtrl has space reserved for status
														//two length bytes, status byte, FIdx,
														//and two CRC bytes.
			if((Result = SetExPhase(EX_START, 0)) == LE_NO_ERROR)
			{
			   Result = SlaveLinkProc();//gets params, executes the function, sets errors if
			   							//necessary and puts return in LCtrl.Buff
			}
			SetExPhase(EX_IDLE, Result); //update LCtrl and put final link status in LCtrl.ReturnStatus
			PostSerialResult(LCtrl.ByteCount, LCtrl.ReturnStatus, LCtrl.FIdx);//they add wrapper
		   	LCtrl.ReturnStatus =  LE_NO_ERROR;
			break;
	}//end of switch(SerCtrl.State) and Serial link handling
#endif //of if USING_SER_LINK
#if (USING_HID_LINK)
	//And this is the USB HID link handling
	//This code is specific to HID streaming link!
	LinkType = HID_LINK; //for benefit of MaxLinkSend(void) and MaxLinkReturn(void)
 	switch(HIDCtrl.State)
	{
		case HID_IDLE:
			break;

		case HID_RECEIVE:
		case HID_RESULT:
			if(HIDLinkTimer == 0)
			{ //Mainly so we never hang up out of sequence(while debugging perhaps)
				HIDCtrl.State = HID_IDLE;
				++HIDTimeouts;
			}
			break;

		case HID_EXECUTE:
			LCtrl.RspBuff = LCtrl.CmdBuff = HIDCtrl.LBuff;
			LCtrl.FIdx = LCtrl.CmdBuf[0];//save the FIdx
			LCtrl.ByteCount = HIDCtrl.ByteCount;
			LCtrl.MaxReturnSize = HIDCtrl.MaxReturnSize;
			if((Result = SetExPhase(EX_START, 0)) == LE_NO_ERROR)
			{
			   Result = SlaveLinkProc();//gets params, executes the function, sets errors if necessary and puts return
			}
			SetExPhase(EX_IDLE, Result); //update LCtrl and put final link status in LCtrl.ReturnStatus
		   	PostHIDResult(LCtrl.ByteCount, LCtrl.ReturnStatus, LCtrl.FIdx);//they add ReturnStatus and FIdx in front of our return packet
	}//end of switch(HIDCtrl.State) and HID link handling
#endif //of if USING_HID_LINK
}
#endif


//Not expected to change for different link transports
U16 RcvChar(void)
{
	switch(LCtrl.ExMode)//probably overkill but we are only allowing char retrieval in appropriate phases
	{
		case EX_START: //We should be fetching FIdx
		case EX_PARM: //We should be fetching params in this phase
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				return LCtrl.CmdBuff[LCtrl.Index++];
			}
			else
			{
				ParamError = TRUE;
			}
			break;

		case EX_CALL: //We may be fetching BLOCK_DOWN bytes in this phase
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
					return LCtrl.CmdBuff[LCtrl.Index++];
			}
			else
			{
				BlockError = TRUE;
			}
			break;

		default:
			PostLogicError(RCV_CHAR_LOGIC_ERROR);
			break;
	}
	return 0XFFFF;
}



//Not expected to change for different link transports
U8 SendChar(U8 C)
{
	switch(LCtrl.ExMode)
	{
		case EX_CALL:
			SetExPhase(EX_UP, 0);//apparently function is sending EX_UP bytes to limit of PacketBuff
			//Intentional case drop-through
			//.
		case EX_UP:
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				LCtrl.RspBuff[LCtrl.Index++] = C;
				return TRUE;
			}
			else
			{
				BlockError = TRUE;
			}
			break;

		case EX_RETURN:
			if(LCtrl.Index <= LCtrl.IndexLimit)
			{
				LCtrl.RspBuff[LCtrl.Index++] = C;
				return TRUE;
			}
			else
			{
				ReturnError = TRUE;//set flag for debugger
			}
			break;

		default:
			PostLogicError(SEND_CHAR_LOGIC_ERROR);
			return FALSE;//we are messed up
	}
	return FALSE;
}
